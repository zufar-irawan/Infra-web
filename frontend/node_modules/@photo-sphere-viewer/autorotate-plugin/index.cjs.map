{"version":3,"sources":["src/index.ts","src/AutorotateButton.ts","src/events.ts","src/icons/play-active.svg","src/icons/play.svg","src/AutorotatePlugin.ts"],"sourcesContent":["import { DEFAULTS, registerButton } from '@photo-sphere-viewer/core';\nimport { AutorotateButton } from './AutorotateButton';\nimport * as events from './events';\n\nregisterButton(AutorotateButton, 'start');\nDEFAULTS.lang[AutorotateButton.id] = 'Automatic rotation';\n\nexport { AutorotatePlugin } from './AutorotatePlugin';\nexport * from './model';\nexport { events };\n","import type { Navbar } from '@photo-sphere-viewer/core';\nimport { AbstractButton } from '@photo-sphere-viewer/core';\nimport type { AutorotatePlugin } from './AutorotatePlugin';\nimport { AutorotateEvent } from './events';\nimport iconActive from './icons/play-active.svg';\nimport icon from './icons/play.svg';\n\nexport class AutorotateButton extends AbstractButton {\n    static override readonly id = 'autorotate';\n\n    private readonly plugin: AutorotatePlugin;\n\n    constructor(navbar: Navbar) {\n        super(navbar, {\n            className: 'psv-autorotate-button',\n            hoverScale: true,\n            collapsable: true,\n            tabbable: true,\n            icon: icon,\n            iconActive: iconActive,\n        });\n\n        this.plugin = this.viewer.getPlugin('autorotate');\n\n        this.plugin?.addEventListener(AutorotateEvent.type, this);\n    }\n\n    override destroy() {\n        this.plugin?.removeEventListener(AutorotateEvent.type, this);\n\n        super.destroy();\n    }\n\n    override isSupported() {\n        return !!this.plugin;\n    }\n\n    handleEvent(e: Event) {\n        if (e instanceof AutorotateEvent) {\n            this.toggleActive(e.autorotateEnabled);\n        }\n    }\n\n    onClick() {\n        if (this.plugin.isEnabled()) {\n            this.plugin.disableOnIdle();\n        }\n        this.plugin.toggle();\n    }\n}\n","import { TypedEvent } from '@photo-sphere-viewer/core';\nimport type { AutorotatePlugin } from './AutorotatePlugin';\n\n/**\n * @event Triggered when the automatic rotation is enabled/disabled\n */\nexport class AutorotateEvent extends TypedEvent<AutorotatePlugin> {\n    static override readonly type = 'autorotate';\n    override type: 'autorotate';\n\n    /** @internal */\n    constructor(public readonly autorotateEnabled: boolean) {\n        super(AutorotateEvent.type);\n    }\n}\n\nexport type AutorotatePluginEvents = AutorotateEvent;\n","<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 41 41\" overflow=\"visible\"><g fill=\"currentColor\" transform-origin=\"center\" transform=\"scale(1.3)\"><path d=\"M40.5 14.1c-.1-.1-1.2-.5-2.898-1-.102 0-.202-.1-.202-.2C34.5 6.5 28 2 20.5 2S6.6 6.5 3.7 12.9c0 .1-.1.1-.2.2-1.7.6-2.8 1-2.9 1l-.6.3v12.1l.6.2c.1 0 1.1.399 2.7.899.1 0 .2.101.2.199C6.3 34.4 12.9 39 20.5 39c7.602 0 14.102-4.6 16.9-11.1 0-.102.1-.102.199-.2 1.699-.601 2.699-1 2.801-1l.6-.3V14.3l-.5-.2zM6.701 11.5C9.7 7 14.8 4 20.5 4c5.8 0 10.9 3 13.8 7.5.2.3-.1.6-.399.5-3.799-1-8.799-2-13.6-2-4.7 0-9.5 1-13.2 2-.3.1-.5-.2-.4-.5zM25.1 20.3L18.7 24c-.3.2-.7 0-.7-.5v-7.4c0-.4.4-.6.7-.4l6.399 3.8c.301.1.301.6.001.8zm9.4 8.901A16.421 16.421 0 0 1 20.5 37c-5.9 0-11.1-3.1-14-7.898-.2-.302.1-.602.4-.5 3.9 1 8.9 2.1 13.6 2.1 5 0 9.9-1 13.602-2 .298-.1.5.198.398.499z\"/></g><!--Created by Nick Bluth from the Noun Project--></svg>\n","<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 41 41\" overflow=\"visible\"><g fill=\"currentColor\" transform-origin=\"center\" transform=\"scale(1.3)\"><path d=\"M40.5 14.1c-.1-.1-1.2-.5-2.899-1-.101 0-.2-.1-.2-.2C34.5 6.5 28 2 20.5 2S6.6 6.5 3.7 12.9c0 .1-.1.1-.2.2-1.7.6-2.8 1-2.9 1l-.6.3v12.1l.6.2c.1 0 1.1.4 2.7.9.1 0 .2.1.2.199C6.3 34.4 12.9 39 20.5 39c7.601 0 14.101-4.6 16.9-11.1 0-.101.1-.101.2-.2 1.699-.6 2.699-1 2.8-1l.6-.3V14.3l-.5-.2zM20.5 4c5.8 0 10.9 3 13.8 7.5.2.3-.1.6-.399.5-3.8-1-8.8-2-13.6-2-4.7 0-9.5 1-13.2 2-.3.1-.5-.2-.4-.5C9.7 7 14.8 4 20.5 4zm0 33c-5.9 0-11.1-3.1-14-7.899-.2-.301.1-.601.4-.5 3.9 1 8.9 2.1 13.6 2.1 5 0 9.9-1 13.601-2 .3-.1.5.2.399.5A16.422 16.422 0 0 1 20.5 37zm18.601-12.1c0 .1-.101.3-.2.3-2.5.9-10.4 3.6-18.4 3.6-7.1 0-15.6-2.699-18.3-3.6C2.1 25.2 2 25 2 24.9V16c0-.1.1-.3.2-.3 2.6-.9 10.6-3.6 18.2-3.6 7.5 0 15.899 2.7 18.5 3.6.1 0 .2.2.2.3v8.9z\"/><path d=\"M18.7 24l6.4-3.7c.3-.2.3-.7 0-.8l-6.4-3.8c-.3-.2-.7 0-.7.4v7.4c0 .5.4.7.7.5z\"/></g><!--Created by Nick Bluth from the Noun Project--></svg>\n","import type { ExtendedPosition, PluginConstructor, Position, Tooltip, Viewer } from '@photo-sphere-viewer/core';\nimport { AbstractConfigurablePlugin, CONSTANTS, events, PSVError, utils } from '@photo-sphere-viewer/core';\nimport type { MarkersPlugin } from '@photo-sphere-viewer/markers-plugin';\nimport type { VideoPlugin } from '@photo-sphere-viewer/video-plugin';\nimport { MathUtils, SplineCurve, Vector2 } from 'three';\nimport { AutorotateEvent, AutorotatePluginEvents } from './events';\nimport { AutorotateKeypoint, AutorotatePluginConfig, UpdatableAutorotatePluginConfig } from './model';\n// import { debugCurve } from '../../shared/autorotate-utils';\n\ntype ParsedAutorotatePluginConfig = Omit<AutorotatePluginConfig, 'autorotateSpeed' | 'autorotatePitch'> & {\n    autorotateSpeed?: number;\n    autorotatePitch?: number;\n};\n\ntype AutorotateKeypointInternal = {\n    position: [number, number];\n    markerId: string;\n    pause: number;\n    tooltip: { content: string; position?: string };\n};\n\nconst getConfig = utils.getConfigParser<AutorotatePluginConfig, ParsedAutorotatePluginConfig>(\n    {\n        autostartDelay: 2000,\n        autostartOnIdle: true,\n        autorotateSpeed: utils.parseSpeed('2rpm'),\n        autorotatePitch: null,\n        autorotateZoomLvl: null,\n        keypoints: null,\n        startFromClosest: true,\n    },\n    {\n        autostartOnIdle: (autostartOnIdle, { rawConfig }) => {\n            if (autostartOnIdle && utils.isNil(rawConfig.autostartDelay)) {\n                utils.logWarn('autostartOnIdle requires a non null autostartDelay');\n                return false;\n            }\n            return autostartOnIdle;\n        },\n        autorotateSpeed: (autorotateSpeed) => {\n            return utils.parseSpeed(autorotateSpeed);\n        },\n        autorotatePitch: (autorotatePitch) => {\n            // autorotatePitch is between -PI/2 and PI/2\n            if (!utils.isNil(autorotatePitch)) {\n                return utils.parseAngle(autorotatePitch, true);\n            }\n            return null;\n        },\n        autorotateZoomLvl: (autorotateZoomLvl) => {\n            if (!utils.isNil(autorotateZoomLvl)) {\n                return MathUtils.clamp(autorotateZoomLvl, 0, 100);\n            }\n            return null;\n        },\n    },\n);\n\nconst NUM_STEPS = 16;\n\nfunction serializePt(position: Position): [number, number] {\n    return [position.yaw, position.pitch];\n}\n\n/**\n * Adds an automatic rotation of the panorama\n */\nexport class AutorotatePlugin extends AbstractConfigurablePlugin<\n    AutorotatePluginConfig,\n    ParsedAutorotatePluginConfig,\n    UpdatableAutorotatePluginConfig,\n    AutorotatePluginEvents\n> {\n    static override readonly id = 'autorotate';\n    static override readonly VERSION = PKG_VERSION;\n    static override readonly configParser = getConfig;\n    static override readonly readonlyOptions: Array<keyof AutorotatePluginConfig> = ['keypoints'];\n\n    private readonly state = {\n        initialStart: true,\n        disableOnIdle: false,\n        /** if the automatic rotation is enabled */\n        enabled: false,\n        /** current index in keypoints */\n        idx: -1,\n        /** curve between idx and idx + 1 */\n        curve: [] as Array<[number, number]>,\n        /** start point of the current step */\n        startStep: null as [number, number],\n        /** end point of the current step */\n        endStep: null as [number, number],\n        /** start time of the current step  */\n        startTime: null as number,\n        /** expected duration of the step */\n        stepDuration: null as number,\n        /** time remaining for the pause */\n        remainingPause: null as number,\n        /** previous timestamp in render loop */\n        lastTime: null as number,\n        /** currently displayed tooltip */\n        tooltip: null as Tooltip,\n    };\n\n    private keypoints: AutorotateKeypointInternal[];\n\n    private video?: VideoPlugin;\n    private markers?: MarkersPlugin;\n\n    static withConfig(config: AutorotatePluginConfig): [PluginConstructor, any] {\n        return [AutorotatePlugin, config];\n    }\n\n    constructor(viewer: Viewer, config: AutorotatePluginConfig) {\n        super(viewer, config);\n\n        this.state.initialStart = !utils.isNil(this.config.autostartDelay);\n    }\n\n    /**\n     * @internal\n     */\n    override init() {\n        super.init();\n\n        this.video = this.viewer.getPlugin('video');\n        this.markers = this.viewer.getPlugin('markers');\n\n        if (this.config.keypoints) {\n            this.setKeypoints(this.config.keypoints);\n            delete this.config.keypoints;\n        }\n\n        this.viewer.addEventListener(events.StopAllEvent.type, this);\n        this.viewer.addEventListener(events.BeforeRenderEvent.type, this);\n\n        // conflict with play/pause of the video plugin\n        if (!this.video) {\n            this.viewer.addEventListener(events.KeypressEvent.type, this);\n        }\n    }\n\n    /**\n     * @internal\n     */\n    override destroy() {\n        this.viewer.removeEventListener(events.StopAllEvent.type, this);\n        this.viewer.removeEventListener(events.BeforeRenderEvent.type, this);\n        this.viewer.removeEventListener(events.KeypressEvent.type, this);\n\n        delete this.video;\n        delete this.markers;\n        delete this.keypoints;\n\n        super.destroy();\n    }\n\n    /**\n     * @internal\n     */\n    handleEvent(e: Event) {\n        switch (e.type) {\n            case events.StopAllEvent.type:\n                this.stop();\n                break;\n\n            case events.BeforeRenderEvent.type: {\n                this.__beforeRender((e as events.BeforeRenderEvent).timestamp);\n                break;\n            }\n\n            case events.KeypressEvent.type:\n                this.__onKeyPress(e as events.KeypressEvent);\n                break;\n        }\n    }\n\n    /**\n     * Changes the keypoints\n     * @throws {@link PSVError} if the configuration is invalid\n     */\n    setKeypoints(keypoints: AutorotateKeypoint[] | null) {\n        if (!keypoints) {\n            this.keypoints = null;\n        } else {\n            if (keypoints.length < 2) {\n                throw new PSVError('At least two points are required');\n            }\n\n            this.keypoints = keypoints.map((pt, i) => {\n                const keypoint: AutorotateKeypointInternal = {\n                    position: null,\n                    markerId: null,\n                    pause: 0,\n                    tooltip: null,\n                };\n\n                let position: ExtendedPosition;\n\n                if (typeof pt === 'string') {\n                    keypoint.markerId = pt;\n                } else if (utils.isExtendedPosition(pt)) {\n                    position = pt;\n                } else {\n                    keypoint.markerId = pt.markerId;\n                    keypoint.pause = pt.pause;\n                    position = pt.position;\n\n                    if (pt.tooltip && typeof pt.tooltip === 'object') {\n                        keypoint.tooltip = pt.tooltip;\n                    } else if (typeof pt.tooltip === 'string') {\n                        keypoint.tooltip = { content: pt.tooltip };\n                    }\n                }\n\n                if (keypoint.markerId) {\n                    if (!this.markers) {\n                        throw new PSVError(`Keypoint #${i} references a marker but the markers plugin is not loaded`);\n                    }\n                    const marker = this.markers.getMarker(keypoint.markerId);\n                    keypoint.position = serializePt(marker.state.position);\n                } else if (position) {\n                    keypoint.position = serializePt(this.viewer.dataHelper.cleanPosition(position));\n                } else {\n                    throw new PSVError(`Keypoint #${i} is missing marker or position`);\n                }\n\n                return keypoint;\n            });\n        }\n\n        if (this.isEnabled()) {\n            this.stop();\n            this.start();\n        }\n    }\n\n    /**\n     * Checks if the automatic rotation is enabled\n     */\n    isEnabled(): boolean {\n        return this.state.enabled;\n    }\n\n    /**\n     * Starts the automatic rotation\n     */\n    start() {\n        if (this.isEnabled()) {\n            return;\n        }\n\n        this.viewer.stopAll();\n\n        if (!this.keypoints) {\n            this.__animate();\n        } else if (this.config.startFromClosest) {\n            this.__shiftKeypoints();\n        }\n\n        this.state.initialStart = false;\n        this.state.disableOnIdle = false;\n        this.state.enabled = true;\n\n        this.dispatchEvent(new AutorotateEvent(true));\n    }\n\n    /**\n     * Stops the automatic rotation\n     */\n    stop() {\n        if (!this.isEnabled()) {\n            return;\n        }\n\n        this.__hideTooltip();\n        this.__reset();\n\n        this.viewer.stopAnimation();\n        this.viewer.dynamics.position.stop();\n        this.viewer.dynamics.zoom.stop();\n\n        this.state.enabled = false;\n\n        this.dispatchEvent(new AutorotateEvent(false));\n    }\n\n    /**\n     * Starts or stops the automatic rotation\n     */\n    toggle() {\n        if (this.isEnabled()) {\n            this.stop();\n        } else {\n            this.start();\n        }\n    }\n\n    /**\n     * @internal\n     */\n    reverse() {\n        if (this.isEnabled() && !this.keypoints) {\n            this.config.autorotateSpeed = -this.config.autorotateSpeed;\n            this.__animate();\n        }\n    }\n\n    /**\n     * @internal\n     */\n    disableOnIdle() {\n        this.state.disableOnIdle = true;\n    }\n\n    /**\n     * Launches the standard animation\n     */\n    private __animate() {\n        // do the zoom before the rotation\n        let p: PromiseLike<any>;\n        if (!utils.isNil(this.config.autorotateZoomLvl)) {\n            p = this.viewer.animate({\n                zoom: this.config.autorotateZoomLvl,\n                // \"2\" is magic, and kinda related to the \"PI/4\" in getAnimationProperties()\n                speed: `${this.viewer.config.zoomSpeed * 2}rpm`,\n            });\n        } else {\n            p = Promise.resolve(true);\n        }\n\n        p.then((done) => {\n            if (done) {\n                this.viewer.dynamics.position.roll(\n                    {\n                        yaw: this.config.autorotateSpeed < 0,\n                    },\n                    Math.abs(this.config.autorotateSpeed / this.viewer.config.moveSpeed),\n                );\n\n                if (!utils.isNil(this.config.autorotatePitch)) {\n                    this.viewer.dynamics.position.goto(\n                        {\n                            pitch: this.config.autorotatePitch,\n                        },\n                        Math.abs(this.config.autorotateSpeed / this.viewer.config.moveSpeed),\n                    );\n                }\n            }\n        });\n    }\n\n    /**\n     * Resets all the curve variables\n     */\n    private __reset() {\n        this.state.idx = -1;\n        this.state.curve = [];\n        this.state.startStep = null;\n        this.state.endStep = null;\n        this.state.startTime = null;\n        this.state.stepDuration = null;\n        this.state.remainingPause = null;\n        this.state.lastTime = null;\n        this.state.tooltip = null;\n    }\n\n    /**\n     * Automatically starts if the delay is reached\n     * Performs keypoints animation\n     */\n    private __beforeRender(timestamp: number) {\n        if (\n            (this.state.initialStart || (this.config.autostartOnIdle && !this.state.disableOnIdle))\n            && this.viewer.state.idleTime > 0\n            && timestamp - this.viewer.state.idleTime > this.config.autostartDelay\n        ) {\n            this.start();\n        }\n\n        if (this.isEnabled() && this.keypoints) {\n            // initialisation\n            if (!this.state.startTime) {\n                this.state.endStep = serializePt(this.viewer.getPosition());\n                this.__nextStep();\n\n                this.state.startTime = timestamp;\n                this.state.lastTime = timestamp;\n            }\n\n            this.__nextFrame(timestamp);\n        }\n    }\n\n    private __shiftKeypoints() {\n        const currentPosition = serializePt(this.viewer.getPosition());\n        const index = this.__findMinIndex(this.keypoints, (keypoint) => {\n            return utils.greatArcDistance(keypoint.position, currentPosition);\n        });\n\n        this.keypoints.push(...this.keypoints.splice(0, index));\n    }\n\n    private __incrementIdx() {\n        this.state.idx++;\n        if (this.state.idx === this.keypoints.length) {\n            this.state.idx = 0;\n        }\n    }\n\n    private __showTooltip() {\n        const keypoint = this.keypoints[this.state.idx];\n\n        if (keypoint.tooltip) {\n            const position = this.viewer.dataHelper.vector3ToViewerCoords(this.viewer.state.direction);\n\n            this.state.tooltip = this.viewer.createTooltip({\n                content: keypoint.tooltip.content,\n                position: keypoint.tooltip.position,\n                top: position.y,\n                left: position.x,\n            });\n        } else if (keypoint.markerId) {\n            const marker = this.markers.getMarker(keypoint.markerId);\n            marker.showTooltip();\n            this.state.tooltip = marker.tooltip;\n        }\n    }\n\n    private __hideTooltip() {\n        if (this.state.tooltip) {\n            const keypoint = this.keypoints[this.state.idx];\n\n            if (keypoint.tooltip) {\n                this.state.tooltip.hide();\n            } else if (keypoint.markerId) {\n                const marker = this.markers.getMarker(keypoint.markerId);\n                marker.hideTooltip();\n            }\n\n            this.state.tooltip = null;\n        }\n    }\n\n    private __nextPoint() {\n        // get the 4 points necessary to compute the current movement\n        // the two points of the current segments and one point before and after\n        const workPoints = [];\n        if (this.state.idx === -1) {\n            const currentPosition = serializePt(this.viewer.getPosition());\n            workPoints.push(\n                currentPosition,\n                currentPosition,\n                this.keypoints[0].position,\n                this.keypoints[1].position,\n            );\n        } else {\n            for (let i = -1; i < 3; i++) {\n                const keypoint = this.state.idx + i < 0\n                    ? this.keypoints[this.keypoints.length - 1]\n                    : this.keypoints[(this.state.idx + i) % this.keypoints.length];\n                workPoints.push(keypoint.position);\n            }\n        }\n\n        // apply offsets to avoid crossing the origin\n        const workVectors = [new Vector2(workPoints[0][0], workPoints[0][1])];\n\n        let k = 0;\n        for (let i = 1; i <= 3; i++) {\n            const d = workPoints[i - 1][0] - workPoints[i][0];\n            if (d > Math.PI) {\n                // crossed the origin left to right\n                k += 1;\n            } else if (d < -Math.PI) {\n                // crossed the origin right to left\n                k -= 1;\n            }\n            if (k !== 0 && i === 1) {\n                // do not modify first point, apply the reverse offset the the previous point instead\n                workVectors[0].x -= k * 2 * Math.PI;\n                k = 0;\n            }\n            workVectors.push(new Vector2(workPoints[i][0] + k * 2 * Math.PI, workPoints[i][1]));\n        }\n\n        const curve: Array<[number, number]> = new SplineCurve(workVectors)\n            .getPoints(NUM_STEPS * 3)\n            .map(p => [p.x, p.y]);\n\n        // debugCurve(this.markers, curve, NUM_STEPS);\n\n        // only keep the curve for the current movement\n        this.state.curve = curve.slice(NUM_STEPS + 1, NUM_STEPS * 2 + 1);\n\n        if (this.state.idx !== -1) {\n            this.state.remainingPause = this.keypoints[this.state.idx].pause;\n\n            if (this.state.remainingPause) {\n                this.__showTooltip();\n            } else {\n                this.__incrementIdx();\n            }\n        } else {\n            this.__incrementIdx();\n        }\n    }\n\n    private __nextStep() {\n        if (this.state.curve.length === 0) {\n            this.__nextPoint();\n\n            // reset transformation made to the previous point\n            this.state.endStep[0] = utils.parseAngle(this.state.endStep[0]);\n        }\n\n        // target next point\n        this.state.startStep = this.state.endStep;\n        this.state.endStep = this.state.curve.shift();\n\n        // compute duration from distance and speed\n        const distance = utils.greatArcDistance(this.state.startStep, this.state.endStep);\n        this.state.stepDuration = (distance * 1000) / Math.abs(this.config.autorotateSpeed);\n\n        if (distance === 0) {\n            // edge case\n            this.__nextStep();\n        }\n    }\n\n    private __nextFrame(timestamp: number) {\n        const ellapsed = timestamp - this.state.lastTime;\n        this.state.lastTime = timestamp;\n\n        // currently paused\n        if (this.state.remainingPause) {\n            this.state.remainingPause = Math.max(0, this.state.remainingPause - ellapsed);\n            if (this.state.remainingPause > 0) {\n                return;\n            } else {\n                this.__hideTooltip();\n                this.__incrementIdx();\n                this.state.startTime = timestamp;\n            }\n        }\n\n        let progress = (timestamp - this.state.startTime) / this.state.stepDuration;\n        if (progress >= 1) {\n            this.__nextStep();\n            progress = 0;\n            this.state.startTime = timestamp;\n        }\n\n        this.viewer.rotate({\n            yaw: this.state.startStep[0] + (this.state.endStep[0] - this.state.startStep[0]) * progress,\n            pitch: this.state.startStep[1] + (this.state.endStep[1] - this.state.startStep[1]) * progress,\n        });\n    }\n\n    private __findMinIndex<T>(array: T[], mapper: (item: T) => number) {\n        let idx = 0;\n        let current = Number.MAX_VALUE;\n\n        array.forEach((item, i) => {\n            const value = mapper(item);\n            if (value < current) {\n                current = value;\n                idx = i;\n            }\n        });\n\n        return idx;\n    }\n\n    private __onKeyPress(e: events.KeypressEvent) {\n        if (this.viewer.state.keyboardEnabled && e.matches(CONSTANTS.KEY_CODES.Space)) {\n            this.toggle();\n            e.preventDefault();\n        }\n    }\n}\n"],"mappings":"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","names":["import_core","import_core","import_core"]}